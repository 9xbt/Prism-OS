

        public struct Font
        {
            public Font(string aCharset, byte[] aRaw, int aSize)
            {
                Charset = aCharset;
                Raw = aRaw;
                Size = aSize;
            }

            public string Charset;
            public byte[] Raw;
            public int Size;
        }

        private static bool AtEdge = false;

        public int DrawChar(Font Font, Color Color, int Index, int X, int Y, bool Calculate = false, bool AntiAliasing = true)
        {
            if (Index < 0)
                return Font.Size / 2;

            int MaxX = 0;
            int SizePerFont = Font.Size * (Font.Size / 8) * Index;
            AtEdge = false;

            for (int h = 0; h < Font.Size; h++)
            {
                for (int aw = 0; aw < Font.Size / 8; aw++)
                {
                    for (int ww = 0; ww < 8; ww++)
                    {
                        if ((Font.Raw[SizePerFont + (h * Font.Size / 8) + aw] & (0x80 >> ww)) != 0)
                        {
                            int max = (aw * 8) + ww;

                            int x = X + max;
                            int y = Y + h;

                            if (!Calculate)
                            {
                                SetPixel(x, y, Color);

                                //if (AntiAliasing && AtEdge)
                                //{
                                //    int tx = X + (aw * 8) + ww - 1;
                                //    int ty = Y + h;
                                //    Color ac = new(GetPixel(tx, ty).ARGB);
                                //    ac.R = (byte)((((((byte)((Color.ARGB >> 16) & 0xFF)) * 96) + ((255 - 96) * ac.R)) >> 8) & 0xFF);
                                //  /  ac.G = (byte)((((((byte)((Color.ARGB >> 8) & 0xFF)) * 96) + ((255 - 96) * ac.G)) >> 8) & 0xFF);
                                //    ac.B = (byte)((((((byte)((Color) & 0xFF)) * 96) + ((255 - 96) * ac.B)) >> 8) & 0xFF);
                                //    SetPixel(tx, ty, ac);
                                //    ac.Dispose();
                                //}

                                AtEdge = false;
                            }

                            if (max > MaxX)
                                MaxX = max;
                        }
                        else
                        {
                            AtEdge = true;
                        }
                    }
                }
            }

            return MaxX;
        }

        public int DrawString(Font Font, Color color, string Text, int X, int Y, bool AntiAlising = true, int Divide = 0)
        {
            int TotalX = 0;
            string[] Lines = Text.Split('\n');

            for (int l = 0; l < Lines.Length; l++)
            {
                int UsedX = 0;
                for (int i = 0; i < Lines[l].Length; i++)
                {
                    char c = Lines[l][i];
                    UsedX += DrawChar(Font, color, Font.Charset.IndexOf(c), UsedX + X, Y + Font.Size * l, false, AntiAlising) + 2 + Divide;
                }
                TotalX += UsedX;
            }

            return TotalX;
        }